"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var we=require("events"),d=require("@walletconnect/core"),Te=require("@walletconnect/types"),r=require("@walletconnect/utils"),De=require("@walletconnect/logger"),R=require("@walletconnect/time"),_=require("@walletconnect/jsonrpc-utils");function ke(w){return w&&typeof w=="object"&&"default"in w?w:{default:w}}var Ue=ke(we);const ce="wc",le=2,pe="client",ee=`${ce}@${le}:${pe}:`,te={name:pe,logger:"error",controller:!1,relayUrl:"wss://relay.walletconnect.org"},$e={session_proposal:"session_proposal",session_update:"session_update",session_extend:"session_extend",session_ping:"session_ping",session_delete:"session_delete",session_expire:"session_expire",session_request:"session_request",session_request_sent:"session_request_sent",session_event:"session_event",proposal_expire:"proposal_expire",session_authenticate:"session_authenticate",session_request_expire:"session_request_expire",session_connect:"session_connect"},Fe={database:":memory:"},he="WALLETCONNECT_DEEPLINK_CHOICE",Ke={created:"history_created",updated:"history_updated",deleted:"history_deleted",sync:"history_sync"},Ge="history",Ye="0.3",Re="proposal",He=R.THIRTY_DAYS,de="Proposal expired",Ie="session",K=R.SEVEN_DAYS,ve="engine",O={wc_sessionPropose:{req:{ttl:R.FIVE_MINUTES,prompt:!0,tag:1100},res:{ttl:R.FIVE_MINUTES,prompt:!1,tag:1101},reject:{ttl:R.FIVE_MINUTES,prompt:!1,tag:1120},autoReject:{ttl:R.FIVE_MINUTES,prompt:!1,tag:1121}},wc_sessionSettle:{req:{ttl:R.FIVE_MINUTES,prompt:!1,tag:1102},res:{ttl:R.FIVE_MINUTES,prompt:!1,tag:1103}},wc_sessionUpdate:{req:{ttl:R.ONE_DAY,prompt:!1,tag:1104},res:{ttl:R.ONE_DAY,prompt:!1,tag:1105}},wc_sessionExtend:{req:{ttl:R.ONE_DAY,prompt:!1,tag:1106},res:{ttl:R.ONE_DAY,prompt:!1,tag:1107}},wc_sessionRequest:{req:{ttl:R.FIVE_MINUTES,prompt:!0,tag:1108},res:{ttl:R.FIVE_MINUTES,prompt:!1,tag:1109}},wc_sessionEvent:{req:{ttl:R.FIVE_MINUTES,prompt:!0,tag:1110},res:{ttl:R.FIVE_MINUTES,prompt:!1,tag:1111}},wc_sessionDelete:{req:{ttl:R.ONE_DAY,prompt:!1,tag:1112},res:{ttl:R.ONE_DAY,prompt:!1,tag:1113}},wc_sessionPing:{req:{ttl:R.ONE_DAY,prompt:!1,tag:1114},res:{ttl:R.ONE_DAY,prompt:!1,tag:1115}},wc_sessionAuthenticate:{req:{ttl:R.ONE_HOUR,prompt:!0,tag:1116},res:{ttl:R.ONE_HOUR,prompt:!1,tag:1117},reject:{ttl:R.FIVE_MINUTES,prompt:!1,tag:1118},autoReject:{ttl:R.FIVE_MINUTES,prompt:!1,tag:1119}}},se={min:R.FIVE_MINUTES,max:R.SEVEN_DAYS},M={idle:"IDLE",active:"ACTIVE"},Ne={eth_sendTransaction:{key:""},eth_sendRawTransaction:{key:""},wallet_sendCalls:{key:""},solana_signTransaction:{key:"signature"},solana_signAllTransactions:{key:"transactions"},solana_signAndSendTransaction:{key:"signature"},sui_signAndExecuteTransaction:{key:"digest"},sui_signTransaction:{key:""},hedera_signAndExecuteTransaction:{key:"transactionId"},hedera_executeTransaction:{key:"transactionId"},near_signTransaction:{key:""},near_signTransactions:{key:""},tron_signTransaction:{key:"txID"},xrpl_signTransaction:{key:""},xrpl_signTransactionFor:{key:""},algo_signTxn:{key:""},sendTransfer:{key:"txid"},stacks_stxTransfer:{key:"txId"},polkadot_signTransaction:{key:""},cosmos_signDirect:{key:""}},fe="request",Pe=["wc_sessionPropose","wc_sessionRequest","wc_authRequest","wc_sessionAuthenticate"],qe="wc",je=1.5,Oe="auth",Ae="authKeys",Ce="pairingTopics",Ve="requests",z=`${qe}@${1.5}:${Oe}:`,B=`${z}:PUB_KEY`;var Je=Object.defineProperty,Qe=Object.defineProperties,Xe=Object.getOwnPropertyDescriptors,be=Object.getOwnPropertySymbols,ze=Object.prototype.hasOwnProperty,Be=Object.prototype.propertyIsEnumerable,ue=(w,a,e)=>a in w?Je(w,a,{enumerable:!0,configurable:!0,writable:!0,value:e}):w[a]=e,v=(w,a)=>{for(var e in a||(a={}))ze.call(a,e)&&ue(w,e,a[e]);if(be)for(var e of be(a))Be.call(a,e)&&ue(w,e,a[e]);return w},A=(w,a)=>Qe(w,Xe(a)),l=(w,a,e)=>ue(w,typeof a!="symbol"?a+"":a,e);class We extends Te.IEngine{constructor(a){super(a),l(this,"name",ve),l(this,"events",new Ue.default),l(this,"initialized",!1),l(this,"requestQueue",{state:M.idle,queue:[]}),l(this,"sessionRequestQueue",{state:M.idle,queue:[]}),l(this,"emittedSessionRequests",new r.LimitedSet({limit:500})),l(this,"requestQueueDelay",R.ONE_SECOND),l(this,"expectedPairingMethodMap",new Map),l(this,"recentlyDeletedMap",new Map),l(this,"recentlyDeletedLimit",200),l(this,"relayMessageCache",[]),l(this,"pendingSessions",new Map),l(this,"init",async()=>{this.initialized||(await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.registerPairingEvents(),await this.registerLinkModeListeners(),this.client.core.pairing.register({methods:Object.keys(O)}),this.initialized=!0,setTimeout(async()=>{await this.processPendingMessageEvents(),this.sessionRequestQueue.queue=this.getPendingSessionRequests(),this.processSessionRequestQueue()},R.toMiliseconds(this.requestQueueDelay)))}),l(this,"connect",async e=>{var t;this.isInitialized(),await this.confirmOnlineStateOrThrow();const s=A(v({},e),{requiredNamespaces:e.requiredNamespaces||{},optionalNamespaces:e.optionalNamespaces||{}});await this.isValidConnect(s),s.optionalNamespaces=r.mergeRequiredAndOptionalNamespaces(s.requiredNamespaces,s.optionalNamespaces),s.requiredNamespaces={};const{pairingTopic:i,requiredNamespaces:n,optionalNamespaces:o,sessionProperties:c,scopedProperties:p,relays:u,authentication:h,walletPay:m}=s,g=((t=h?.[0])==null?void 0:t.ttl)||O.wc_sessionPropose.req.ttl||R.FIVE_MINUTES;this.validateRequestExpiry(g);let E=i,S,y=!1;try{if(E){const f=this.client.core.pairing.pairings.get(E);this.client.logger.warn("connect() with existing pairing topic is deprecated and will be removed in the next major release."),y=f.active}}catch(f){throw this.client.logger.error(`connect() -> pairing.get(${E}) failed`),f}if(!E||!y){const{topic:f,uri:q}=await this.client.core.pairing.create({internal:{skipSubscribe:!0}});E=f,S=q}if(!E){const{message:f}=r.getInternalError("NO_MATCHING_KEY",`connect() pairing topic: ${E}`);throw new Error(f)}const N=await this.client.core.crypto.generateKeyPair(),I=r.calcExpiry(g),P=v(A(v(v({requiredNamespaces:n,optionalNamespaces:o,relays:u??[{protocol:d.RELAYER_DEFAULT_PROTOCOL}],proposer:{publicKey:N,metadata:this.client.metadata},expiryTimestamp:I,pairingTopic:E},c&&{sessionProperties:c}),p&&{scopedProperties:p}),{id:_.payloadId()}),(h||m)&&{requests:{authentication:h?.map(f=>{const{domain:q,chains:W,nonce:Y,uri:U,exp:G,nbf:H,type:$,statement:j,requestId:J,resources:b,signatureTypes:L}=f;return{domain:q,chains:W,nonce:Y,type:$??"caip122",aud:U,version:"1",iat:new Date().toISOString(),exp:G,nbf:H,statement:j,requestId:J,resources:b,signatureTypes:L}}),walletPay:m}}),C=r.engineEvent("session_connect",P.id),{reject:x,resolve:V,done:D}=r.createDelayedPromise(g,de),k=({id:f})=>{f===P.id&&(this.client.events.off("proposal_expire",k),this.pendingSessions.delete(P.id),this.events.emit(C,{error:{message:de,code:0}}))};return this.client.events.on("proposal_expire",k),this.events.once(C,({error:f,session:q})=>{this.client.events.off("proposal_expire",k),f?x(f):q&&V(q)}),await this.setProposal(P.id,P),await this.sendProposeSession({proposal:P,publishOpts:{internal:{throwOnFailedPublish:!0},tvf:{correlationId:P.id}}}).catch(f=>{throw this.deleteProposal(P.id),f}),{uri:S,approval:D}}),l(this,"pair",async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{return await this.client.core.pairing.pair(e)}catch(t){throw this.client.logger.error("pair() failed"),t}}),l(this,"approve",async e=>{var t,s,i;const n=this.client.core.eventClient.createEvent({properties:{topic:(t=e?.id)==null?void 0:t.toString(),trace:[d.EVENT_CLIENT_SESSION_TRACES.session_approve_started]}});try{this.isInitialized(),await this.confirmOnlineStateOrThrow()}catch(q){throw n.setError(d.EVENT_CLIENT_SESSION_ERRORS.no_internet_connection),q}try{await this.isValidProposalId(e?.id)}catch(q){throw this.client.logger.error(`approve() -> proposal.get(${e?.id}) failed`),n.setError(d.EVENT_CLIENT_SESSION_ERRORS.proposal_not_found),q}try{await this.isValidApprove(e)}catch(q){throw this.client.logger.error("approve() -> isValidApprove() failed"),n.setError(d.EVENT_CLIENT_SESSION_ERRORS.session_approve_namespace_validation_failure),q}const{id:o,relayProtocol:c,namespaces:p,sessionProperties:u,scopedProperties:h,sessionConfig:m,proposalRequestsResponses:g}=e,E=this.client.proposal.get(o);this.client.core.eventClient.deleteEvent({eventId:n.eventId});const{pairingTopic:S,proposer:y,requiredNamespaces:N,optionalNamespaces:I}=E;let P=(s=this.client.core.eventClient)==null?void 0:s.getEvent({topic:S});P||(P=(i=this.client.core.eventClient)==null?void 0:i.createEvent({type:d.EVENT_CLIENT_SESSION_TRACES.session_approve_started,properties:{topic:S,trace:[d.EVENT_CLIENT_SESSION_TRACES.session_approve_started,d.EVENT_CLIENT_SESSION_TRACES.session_namespaces_validation_success]}}));const C=await this.client.core.crypto.generateKeyPair(),x=y.publicKey,V=await this.client.core.crypto.generateSharedKey(C,x),D=A(v(v(v({relay:{protocol:c??"irn"},namespaces:p,controller:{publicKey:C,metadata:this.client.metadata},expiry:r.calcExpiry(K)},u&&{sessionProperties:u}),h&&{scopedProperties:h}),m&&{sessionConfig:m}),{proposalRequestsResponses:g}),k=d.TRANSPORT_TYPES.relay;P.addTrace(d.EVENT_CLIENT_SESSION_TRACES.subscribing_session_topic);try{await this.client.core.relayer.subscribe(V,{transportType:k,internal:{skipSubscribe:!0}})}catch(q){throw P.setError(d.EVENT_CLIENT_SESSION_ERRORS.subscribe_session_topic_failure),q}P.addTrace(d.EVENT_CLIENT_SESSION_TRACES.subscribe_session_topic_success);const f=A(v({},D),{topic:V,requiredNamespaces:N,optionalNamespaces:I,pairingTopic:S,acknowledged:!1,self:D.controller,peer:{publicKey:y.publicKey,metadata:y.metadata},controller:C,transportType:d.TRANSPORT_TYPES.relay,authentication:g?.authentication,walletPayResult:g?.walletPay});await this.client.session.set(V,f),P.addTrace(d.EVENT_CLIENT_SESSION_TRACES.store_session);try{await this.sendApproveSession({sessionTopic:V,proposal:E,pairingProposalResponse:{relay:{protocol:c??"irn"},responderPublicKey:C},sessionSettleRequest:D,publishOpts:{internal:{throwOnFailedPublish:!0},tvf:v({correlationId:o},this.getTVFApproveParams(f))}}),P.addTrace(d.EVENT_CLIENT_SESSION_TRACES.session_approve_publish_success)}catch(q){throw this.client.logger.error(q),this.client.session.delete(V,r.getSdkError("USER_DISCONNECTED")),await this.client.core.relayer.unsubscribe(V),q}return this.client.core.eventClient.deleteEvent({eventId:P.eventId}),await this.client.core.pairing.updateMetadata({topic:S,metadata:y.metadata}),await this.deleteProposal(o),await this.client.core.pairing.activate({topic:S}),await this.setExpiry(V,r.calcExpiry(K)),{topic:V,acknowledged:()=>Promise.resolve(this.client.session.get(V))}}),l(this,"reject",async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidReject(e)}catch(n){throw this.client.logger.error("reject() -> isValidReject() failed"),n}const{id:t,reason:s}=e;let i;try{i=this.client.proposal.get(t).pairingTopic}catch(n){throw this.client.logger.error(`reject() -> proposal.get(${t}) failed`),n}i&&await this.sendError({id:t,topic:i,error:s,rpcOpts:O.wc_sessionPropose.reject}),await this.deleteProposal(t)}),l(this,"update",async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidUpdate(e)}catch(h){throw this.client.logger.error("update() -> isValidUpdate() failed"),h}const{topic:t,namespaces:s}=e,{done:i,resolve:n,reject:o}=r.createDelayedPromise(R.FIVE_MINUTES,"Session update request expired without receiving any acknowledgement"),c=_.payloadId(),p=_.getBigIntRpcId().toString(),u=this.client.session.get(t).namespaces;return this.events.once(r.engineEvent("session_update",c),({error:h})=>{h?o(h):n()}),await this.client.session.update(t,{namespaces:s}),await this.sendRequest({topic:t,method:"wc_sessionUpdate",params:{namespaces:s},throwOnFailedPublish:!0,clientRpcId:c,relayRpcId:p}).catch(h=>{this.client.logger.error(h),this.client.session.update(t,{namespaces:u}),o(h)}),{acknowledged:i}}),l(this,"extend",async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidExtend(e)}catch(c){throw this.client.logger.error("extend() -> isValidExtend() failed"),c}const{topic:t}=e,s=_.payloadId(),{done:i,resolve:n,reject:o}=r.createDelayedPromise(R.FIVE_MINUTES,"Session extend request expired without receiving any acknowledgement");return this.events.once(r.engineEvent("session_extend",s),({error:c})=>{c?o(c):n()}),await this.setExpiry(t,r.calcExpiry(K)),this.sendRequest({topic:t,method:"wc_sessionExtend",params:{},clientRpcId:s,throwOnFailedPublish:!0}).catch(c=>{o(c)}),{acknowledged:i}}),l(this,"request",async e=>{this.isInitialized();try{await this.isValidRequest(e)}catch(y){throw this.client.logger.error("request() -> isValidRequest() failed"),y}const{chainId:t,request:s,topic:i,expiry:n=O.wc_sessionRequest.req.ttl}=e,o=this.client.session.get(i);o?.transportType===d.TRANSPORT_TYPES.relay&&await this.confirmOnlineStateOrThrow();const c=_.payloadId(),p=_.getBigIntRpcId().toString(),{done:u,resolve:h,reject:m}=r.createDelayedPromise(n,"Request expired. Please try again.");this.events.once(r.engineEvent("session_request",c),({error:y,result:N})=>{y?m(y):h(N)});const g="wc_sessionRequest",E=this.getAppLinkIfEnabled(o.peer.metadata,o.transportType);if(E)return await this.sendRequest({clientRpcId:c,relayRpcId:p,topic:i,method:g,params:{request:A(v({},s),{expiryTimestamp:r.calcExpiry(n)}),chainId:t},expiry:n,throwOnFailedPublish:!0,appLink:E}).catch(y=>m(y)),this.client.events.emit("session_request_sent",{topic:i,request:s,chainId:t,id:c}),await u();const S={request:A(v({},s),{expiryTimestamp:r.calcExpiry(n)}),chainId:t};return await Promise.all([new Promise(async y=>{await this.sendRequest({clientRpcId:c,relayRpcId:p,topic:i,method:g,params:S,expiry:n,throwOnFailedPublish:!0,tvf:this.getTVFParams(c,S)}).catch(N=>m(N)),this.client.events.emit("session_request_sent",{topic:i,request:s,chainId:t,id:c}),y()}),new Promise(async y=>{var N;if(!((N=o.sessionConfig)!=null&&N.disableDeepLink)){const I=await r.getDeepLink(this.client.core.storage,he);await r.handleDeeplinkRedirect({id:c,topic:i,wcDeepLink:I})}y()}),u()]).then(y=>y[2])}),l(this,"respond",async e=>{var t,s;this.isInitialized();const i=this.client.core.eventClient.createEvent({properties:{topic:e?.topic||((s=(t=e?.response)==null?void 0:t.id)==null?void 0:s.toString()),trace:[d.EVENT_CLIENT_SESSION_TRACES.session_request_response_started]}});try{await this.isValidRespond(e)}catch(h){throw i.addTrace(h?.message),i.setError(d.EVENT_CLIENT_SESSION_ERRORS.session_request_response_validation_failure),h}i.addTrace(d.EVENT_CLIENT_SESSION_TRACES.session_request_response_validation_success);const{topic:n,response:o}=e,{id:c}=o,p=this.client.session.get(n);p.transportType===d.TRANSPORT_TYPES.relay&&await this.confirmOnlineStateOrThrow();const u=this.getAppLinkIfEnabled(p.peer.metadata,p.transportType);try{i.addTrace(d.EVENT_CLIENT_SESSION_TRACES.session_request_response_publish_started),_.isJsonRpcResult(o)?await this.sendResult({id:c,topic:n,result:o.result,throwOnFailedPublish:!0,appLink:u}):_.isJsonRpcError(o)&&await this.sendError({id:c,topic:n,error:o.error,appLink:u}),this.cleanupAfterResponse(e)}catch(h){throw i.addTrace(h?.message),i.setError(d.EVENT_CLIENT_SESSION_ERRORS.session_request_response_publish_failure),h}}),l(this,"ping",async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidPing(e)}catch(s){throw this.client.logger.error("ping() -> isValidPing() failed"),s}const{topic:t}=e;if(this.client.session.keys.includes(t)){const s=_.payloadId(),i=_.getBigIntRpcId().toString(),{done:n,resolve:o,reject:c}=r.createDelayedPromise(R.FIVE_MINUTES,"Ping request expired without receiving any acknowledgement");this.events.once(r.engineEvent("session_ping",s),({error:p})=>{p?c(p):o()}),await Promise.all([this.sendRequest({topic:t,method:"wc_sessionPing",params:{},throwOnFailedPublish:!0,clientRpcId:s,relayRpcId:i}),n()])}else this.client.core.pairing.pairings.keys.includes(t)&&(this.client.logger.warn("ping() on pairing topic is deprecated and will be removed in the next major release."),await this.client.core.pairing.ping({topic:t}))}),l(this,"emit",async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow(),await this.isValidEmit(e);const{topic:t,event:s,chainId:i}=e,n=_.getBigIntRpcId().toString(),o=_.payloadId();await this.sendRequest({topic:t,method:"wc_sessionEvent",params:{event:s,chainId:i},throwOnFailedPublish:!0,relayRpcId:n,clientRpcId:o})}),l(this,"disconnect",async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow(),await this.isValidDisconnect(e);const{topic:t}=e;if(this.client.session.keys.includes(t))await this.sendRequest({topic:t,method:"wc_sessionDelete",params:r.getSdkError("USER_DISCONNECTED"),throwOnFailedPublish:!0}),await this.deleteSession({topic:t,emitEvent:!1});else if(this.client.core.pairing.pairings.keys.includes(t))await this.client.core.pairing.disconnect({topic:t});else{const{message:s}=r.getInternalError("MISMATCHED_TOPIC",`Session or pairing topic not found: ${t}`);throw new Error(s)}}),l(this,"find",e=>(this.isInitialized(),this.client.session.getAll().filter(t=>r.isSessionCompatible(t,e)))),l(this,"getPendingSessionRequests",()=>this.client.pendingRequest.getAll()),l(this,"authenticate",async(e,t)=>{var s;this.isInitialized(),this.isValidAuthenticate(e);const i=t&&this.client.core.linkModeSupportedApps.includes(t)&&((s=this.client.metadata.redirect)==null?void 0:s.linkMode),n=i?d.TRANSPORT_TYPES.link_mode:d.TRANSPORT_TYPES.relay;n===d.TRANSPORT_TYPES.relay&&await this.confirmOnlineStateOrThrow();const{chains:o,statement:c="",uri:p,domain:u,nonce:h,type:m,exp:g,nbf:E,methods:S=[],expiry:y}=e,N=[...e.resources||[]],{topic:I,uri:P}=await this.client.core.pairing.create({methods:["wc_sessionAuthenticate"],transportType:n});this.client.logger.info({message:"Generated new pairing",pairing:{topic:I,uri:P}});const C=await this.client.core.crypto.generateKeyPair(),x=r.hashKey(C);if(await Promise.all([this.client.auth.authKeys.set(B,{responseTopic:x,publicKey:C}),this.client.auth.pairingTopics.set(x,{topic:x,pairingTopic:I})]),await this.client.core.relayer.subscribe(x,{transportType:n}),this.client.logger.info(`sending request to new pairing topic: ${I}`),S.length>0){const{namespace:b}=r.parseChainId(o[0]);let L=r.createEncodedRecap(b,"request",S);r.getRecapFromResources(N)&&(L=r.mergeEncodedRecaps(L,N.pop())),N.push(L)}const V=y&&y>O.wc_sessionAuthenticate.req.ttl?y:O.wc_sessionAuthenticate.req.ttl,D={authPayload:{type:m??"caip122",chains:o,statement:c,aud:p,domain:u,version:"1",nonce:h,iat:new Date().toISOString(),exp:g,nbf:E,resources:N},requester:{publicKey:C,metadata:this.client.metadata},expiryTimestamp:r.calcExpiry(V)},k={eip155:{chains:o,methods:[...new Set(["personal_sign",...S])],events:["chainChanged","accountsChanged"]}},f={requiredNamespaces:{},optionalNamespaces:k,relays:[{protocol:"irn"}],pairingTopic:I,proposer:{publicKey:C,metadata:this.client.metadata},expiryTimestamp:r.calcExpiry(O.wc_sessionPropose.req.ttl),id:_.payloadId()},{done:q,resolve:W,reject:Y}=r.createDelayedPromise(V,"Request expired"),U=_.payloadId(),G=r.engineEvent("session_connect",f.id),H=r.engineEvent("session_request",U),$=async({error:b,session:L})=>{this.events.off(H,j),b?Y(b):L&&W({session:L})},j=async b=>{var L,Ee,ye;if(await this.deletePendingAuthRequest(U,{message:"fulfilled",code:0}),b.error){const X=r.getSdkError("WC_METHOD_UNSUPPORTED","wc_sessionAuthenticate");return b.error.code===X.code?void 0:(this.events.off(G,$),Y(b.error.message))}await this.deleteProposal(f.id),this.events.off(G,$);const{cacaos:me,responder:F}=b.result,re=[],_e=[];for(const X of me){await r.validateSignedCacao({cacao:X,projectId:this.client.core.projectId})||(this.client.logger.error(X,"Signature verification failed"),Y(r.getSdkError("SESSION_SETTLEMENT_FAILED","Signature verification failed")));const{p:ne}=X,oe=r.getRecapFromResources(ne.resources),Se=[r.getNamespacedDidChainId(ne.iss)],Le=r.getDidAddress(ne.iss);if(oe){const ae=r.getMethodsFromRecap(oe),Me=r.getChainsFromRecap(oe);re.push(...ae),Se.push(...Me)}for(const ae of Se)_e.push(`${ae}:${Le}`)}const Q=await this.client.core.crypto.generateSharedKey(C,F.publicKey);let Z;re.length>0&&(Z={topic:Q,acknowledged:!0,self:{publicKey:C,metadata:this.client.metadata},peer:F,controller:F.publicKey,expiry:r.calcExpiry(K),requiredNamespaces:{},optionalNamespaces:{},relay:{protocol:"irn"},pairingTopic:I,namespaces:r.buildNamespacesFromAuth([...new Set(re)],[...new Set(_e)]),transportType:n},await this.client.core.relayer.subscribe(Q,{transportType:n}),await this.client.session.set(Q,Z),I&&await this.client.core.pairing.updateMetadata({topic:I,metadata:F.metadata}),Z=this.client.session.get(Q)),(L=this.client.metadata.redirect)!=null&&L.linkMode&&(Ee=F.metadata.redirect)!=null&&Ee.linkMode&&(ye=F.metadata.redirect)!=null&&ye.universal&&t&&(this.client.core.addLinkModeSupportedApp(F.metadata.redirect.universal),this.client.session.update(Q,{transportType:d.TRANSPORT_TYPES.link_mode})),W({auths:me,session:Z})};this.events.once(G,$),this.events.once(H,j);let J;try{if(i){const b=_.formatJsonRpcRequest("wc_sessionAuthenticate",D,U);this.client.core.history.set(I,b);const L=await this.client.core.crypto.encode("",b,{type:r.TYPE_2,encoding:r.BASE64URL});J=r.getLinkModeURL(t,I,L)}else await Promise.all([this.sendRequest({topic:I,method:"wc_sessionAuthenticate",params:D,expiry:e.expiry,throwOnFailedPublish:!0,clientRpcId:U}),this.sendRequest({topic:I,method:"wc_sessionPropose",params:f,expiry:O.wc_sessionPropose.req.ttl,throwOnFailedPublish:!0,clientRpcId:f.id})])}catch(b){throw this.events.off(G,$),this.events.off(H,j),b}return await this.setProposal(f.id,f),await this.setAuthRequest(U,{request:A(v({},D),{verifyContext:{}}),pairingTopic:I,transportType:n}),{uri:J??P,response:q}}),l(this,"approveSessionAuthenticate",async e=>{const{id:t,auths:s}=e,i=this.client.core.eventClient.createEvent({properties:{topic:t.toString(),trace:[d.EVENT_CLIENT_AUTHENTICATE_TRACES.authenticated_session_approve_started]}});try{this.isInitialized()}catch(y){throw i.setError(d.EVENT_CLIENT_AUTHENTICATE_ERRORS.no_internet_connection),y}const n=this.getPendingAuthRequest(t);if(!n)throw i.setError(d.EVENT_CLIENT_AUTHENTICATE_ERRORS.authenticated_session_pending_request_not_found),new Error(`Could not find pending auth request with id ${t}`);const o=n.transportType||d.TRANSPORT_TYPES.relay;o===d.TRANSPORT_TYPES.relay&&await this.confirmOnlineStateOrThrow();const c=n.requester.publicKey,p=await this.client.core.crypto.generateKeyPair(),u=r.hashKey(c),h={type:r.TYPE_1,receiverPublicKey:c,senderPublicKey:p},m=[],g=[];for(const y of s){if(!await r.validateSignedCacao({cacao:y,projectId:this.client.core.projectId})){i.setError(d.EVENT_CLIENT_AUTHENTICATE_ERRORS.invalid_cacao);const x=r.getSdkError("SESSION_SETTLEMENT_FAILED","Signature verification failed");throw await this.sendError({id:t,topic:u,error:x,encodeOpts:h}),new Error(x.message)}i.addTrace(d.EVENT_CLIENT_AUTHENTICATE_TRACES.cacaos_verified);const{p:N}=y,I=r.getRecapFromResources(N.resources),P=[r.getNamespacedDidChainId(N.iss)],C=r.getDidAddress(N.iss);if(I){const x=r.getMethodsFromRecap(I),V=r.getChainsFromRecap(I);m.push(...x),P.push(...V)}for(const x of P)g.push(`${x}:${C}`)}const E=await this.client.core.crypto.generateSharedKey(p,c);i.addTrace(d.EVENT_CLIENT_AUTHENTICATE_TRACES.create_authenticated_session_topic);let S;if(m?.length>0){S={topic:E,acknowledged:!0,self:{publicKey:p,metadata:this.client.metadata},peer:{publicKey:c,metadata:n.requester.metadata},controller:c,expiry:r.calcExpiry(K),authentication:s,requiredNamespaces:{},optionalNamespaces:{},relay:{protocol:"irn"},pairingTopic:n.pairingTopic,namespaces:r.buildNamespacesFromAuth([...new Set(m)],[...new Set(g)]),transportType:o},i.addTrace(d.EVENT_CLIENT_AUTHENTICATE_TRACES.subscribing_authenticated_session_topic);try{await this.client.core.relayer.subscribe(E,{transportType:o})}catch(y){throw i.setError(d.EVENT_CLIENT_AUTHENTICATE_ERRORS.subscribe_authenticated_session_topic_failure),y}i.addTrace(d.EVENT_CLIENT_AUTHENTICATE_TRACES.subscribe_authenticated_session_topic_success),await this.client.session.set(E,S),i.addTrace(d.EVENT_CLIENT_AUTHENTICATE_TRACES.store_authenticated_session),await this.client.core.pairing.updateMetadata({topic:n.pairingTopic,metadata:n.requester.metadata})}i.addTrace(d.EVENT_CLIENT_AUTHENTICATE_TRACES.publishing_authenticated_session_approve);try{await this.sendResult({topic:u,id:t,result:{cacaos:s,responder:{publicKey:p,metadata:this.client.metadata}},encodeOpts:h,throwOnFailedPublish:!0,appLink:this.getAppLinkIfEnabled(n.requester.metadata,o)})}catch(y){throw i.setError(d.EVENT_CLIENT_AUTHENTICATE_ERRORS.authenticated_session_approve_publish_failure),y}return await this.client.auth.requests.delete(t,{message:"fulfilled",code:0}),await this.client.core.pairing.activate({topic:n.pairingTopic}),this.client.core.eventClient.deleteEvent({eventId:i.eventId}),{session:S}}),l(this,"rejectSessionAuthenticate",async e=>{this.isInitialized();const{id:t,reason:s}=e,i=this.getPendingAuthRequest(t);if(!i)throw new Error(`Could not find pending auth request with id ${t}`);i.transportType===d.TRANSPORT_TYPES.relay&&await this.confirmOnlineStateOrThrow();const n=i.requester.publicKey,o=await this.client.core.crypto.generateKeyPair(),c=r.hashKey(n),p={type:r.TYPE_1,receiverPublicKey:n,senderPublicKey:o};await this.sendError({id:t,topic:c,error:s,encodeOpts:p,rpcOpts:O.wc_sessionAuthenticate.reject,appLink:this.getAppLinkIfEnabled(i.requester.metadata,i.transportType)}),await this.client.auth.requests.delete(t,{message:"rejected",code:0}),await this.deleteProposal(t)}),l(this,"formatAuthMessage",e=>{this.isInitialized();const{request:t,iss:s}=e;return r.formatMessage(t,s)}),l(this,"processRelayMessageCache",()=>{setTimeout(async()=>{if(this.relayMessageCache.length!==0)for(;this.relayMessageCache.length>0;)try{const e=this.relayMessageCache.shift();e&&await this.onRelayMessage(e)}catch(e){this.client.logger.error(e)}},50)}),l(this,"cleanupDuplicatePairings",async e=>{if(e.pairingTopic)try{const t=this.client.core.pairing.pairings.get(e.pairingTopic),s=this.client.core.pairing.pairings.getAll().filter(i=>{var n,o;return((n=i.peerMetadata)==null?void 0:n.url)&&((o=i.peerMetadata)==null?void 0:o.url)===e.peer.metadata.url&&i.topic&&i.topic!==t.topic});if(s.length===0)return;this.client.logger.info(`Cleaning up ${s.length} duplicate pairing(s)`),await Promise.all(s.map(i=>this.client.core.pairing.disconnect({topic:i.topic}))),this.client.logger.info("Duplicate pairings clean up finished")}catch(t){this.client.logger.error(t)}}),l(this,"deleteSession",async e=>{var t;const{topic:s,expirerHasDeleted:i=!1,emitEvent:n=!0,id:o=0}=e,{self:c}=this.client.session.get(s);await this.client.core.relayer.unsubscribe(s),await this.client.session.delete(s,r.getSdkError("USER_DISCONNECTED")),this.addToRecentlyDeleted(s,"session"),this.client.core.crypto.keychain.has(c.publicKey)&&await this.client.core.crypto.deleteKeyPair(c.publicKey),this.client.core.crypto.keychain.has(s)&&await this.client.core.crypto.deleteSymKey(s),i||this.client.core.expirer.del(s),this.client.core.storage.removeItem(he).catch(p=>this.client.logger.warn(p)),s===((t=this.sessionRequestQueue.queue[0])==null?void 0:t.topic)&&(this.sessionRequestQueue.state=M.idle),await Promise.all(this.getPendingSessionRequests().filter(p=>p.topic===s).map(p=>this.deletePendingSessionRequest(p.id,r.getSdkError("USER_DISCONNECTED")))),n&&this.client.events.emit("session_delete",{id:o,topic:s})}),l(this,"deleteProposal",async(e,t)=>{if(t)try{const s=this.client.proposal.get(e),i=this.client.core.eventClient.getEvent({topic:s.pairingTopic});i?.setError(d.EVENT_CLIENT_SESSION_ERRORS.proposal_expired)}catch{}await Promise.all([this.client.proposal.delete(e,r.getSdkError("USER_DISCONNECTED")),t?Promise.resolve():this.client.core.expirer.del(e)]),this.addToRecentlyDeleted(e,"proposal")}),l(this,"deletePendingSessionRequest",async(e,t,s=!1)=>{await Promise.all([this.client.pendingRequest.delete(e,t),s?Promise.resolve():this.client.core.expirer.del(e)]),this.addToRecentlyDeleted(e,"request"),this.sessionRequestQueue.queue=this.sessionRequestQueue.queue.filter(i=>i.id!==e),s&&(this.sessionRequestQueue.state=M.idle,this.client.events.emit("session_request_expire",{id:e}))}),l(this,"deletePendingAuthRequest",async(e,t,s=!1)=>{await Promise.all([this.client.auth.requests.delete(e,t),s?Promise.resolve():this.client.core.expirer.del(e)])}),l(this,"setExpiry",async(e,t)=>{this.client.session.keys.includes(e)&&(this.client.core.expirer.set(e,t),await this.client.session.update(e,{expiry:t}))}),l(this,"setProposal",async(e,t)=>{this.client.core.expirer.set(e,r.calcExpiry(O.wc_sessionPropose.req.ttl)),await this.client.proposal.set(e,t)}),l(this,"setAuthRequest",async(e,t)=>{const{request:s,pairingTopic:i,transportType:n=d.TRANSPORT_TYPES.relay}=t;this.client.core.expirer.set(e,s.expiryTimestamp),await this.client.auth.requests.set(e,{authPayload:s.authPayload,requester:s.requester,expiryTimestamp:s.expiryTimestamp,id:e,pairingTopic:i,verifyContext:s.verifyContext,transportType:n})}),l(this,"setPendingSessionRequest",async e=>{const{id:t,topic:s,params:i,verifyContext:n}=e,o=i.request.expiryTimestamp||r.calcExpiry(O.wc_sessionRequest.req.ttl);this.client.core.expirer.set(t,o),await this.client.pendingRequest.set(t,{id:t,topic:s,params:i,verifyContext:n})}),l(this,"sendRequest",async e=>{const{topic:t,method:s,params:i,expiry:n,relayRpcId:o,clientRpcId:c,throwOnFailedPublish:p,appLink:u,tvf:h,publishOpts:m={}}=e,g=_.formatJsonRpcRequest(s,i,c);let E;const S=!!u;try{const I=S?r.BASE64URL:r.BASE64;E=await this.client.core.crypto.encode(t,g,{encoding:I})}catch(I){throw await this.cleanup(),this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${t} failed`),I}let y;if(Pe.includes(s)){const I=r.hashMessage(JSON.stringify(g)),P=r.hashMessage(E);y=await this.client.core.verify.register({id:P,decryptedId:I})}const N=v(v({},O[s].req),m);if(N.attestation=y,n&&(N.ttl=n),o&&(N.id=o),this.client.core.history.set(t,g),S){const I=r.getLinkModeURL(u,t,E);await global.Linking.openURL(I,this.client.name)}else N.tvf=A(v({},h),{correlationId:g.id}),p?(N.internal=A(v({},N.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(t,E,N)):this.client.core.relayer.publish(t,E,N).catch(I=>this.client.logger.error(I));return g.id}),l(this,"sendProposeSession",async e=>{const{proposal:t,publishOpts:s}=e,i=_.formatJsonRpcRequest("wc_sessionPropose",t,t.id);this.client.core.history.set(t.pairingTopic,i);const n=await this.client.core.crypto.encode(t.pairingTopic,i,{encoding:r.BASE64}),o=r.hashMessage(JSON.stringify(i)),c=r.hashMessage(n),p=await this.client.core.verify.register({id:c,decryptedId:o});await this.client.core.relayer.publishCustom({payload:{pairingTopic:t.pairingTopic,sessionProposal:n},opts:A(v({},s),{publishMethod:"wc_proposeSession",attestation:p})})}),l(this,"sendApproveSession",async e=>{const{sessionTopic:t,pairingProposalResponse:s,proposal:i,sessionSettleRequest:n,publishOpts:o}=e,c=_.formatJsonRpcResult(i.id,s),p=await this.client.core.crypto.encode(i.pairingTopic,c,{encoding:r.BASE64}),u=_.formatJsonRpcRequest("wc_sessionSettle",n,o?.id),h=await this.client.core.crypto.encode(t,u,{encoding:r.BASE64});this.client.core.history.set(t,u),await this.client.core.relayer.publishCustom({payload:{sessionTopic:t,pairingTopic:i.pairingTopic,sessionProposalResponse:p,sessionSettlementRequest:h},opts:A(v({},o),{publishMethod:"wc_approveSession"})})}),l(this,"sendResult",async e=>{const{id:t,topic:s,result:i,throwOnFailedPublish:n,encodeOpts:o,appLink:c}=e,p=_.formatJsonRpcResult(t,i);let u;const h=c&&typeof(global==null?void 0:global.Linking)<"u";try{const E=h?r.BASE64URL:r.BASE64;u=await this.client.core.crypto.encode(s,p,A(v({},o||{}),{encoding:E}))}catch(E){throw await this.cleanup(),this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${s} failed`),E}let m,g;try{m=await this.client.core.history.get(s,t);const E=m.request;try{g=this.getTVFParams(t,E.params,i)}catch(S){this.client.logger.warn(`sendResult() -> getTVFParams() failed: ${S?.message}`)}}catch(E){throw this.client.logger.error(`sendResult() -> history.get(${s}, ${t}) failed`),E}if(h){const E=r.getLinkModeURL(c,s,u);await global.Linking.openURL(E,this.client.name)}else{const E=m.request.method,S=O[E].res;S.tvf=A(v({},g),{correlationId:t}),n?(S.internal=A(v({},S.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(s,u,S)):this.client.core.relayer.publish(s,u,S).catch(y=>this.client.logger.error(y))}await this.client.core.history.resolve(p)}),l(this,"sendError",async e=>{const{id:t,topic:s,error:i,encodeOpts:n,rpcOpts:o,appLink:c}=e,p=_.formatJsonRpcError(t,i);let u;const h=c&&typeof(global==null?void 0:global.Linking)<"u";try{const g=h?r.BASE64URL:r.BASE64;u=await this.client.core.crypto.encode(s,p,A(v({},n||{}),{encoding:g}))}catch(g){throw await this.cleanup(),this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${s} failed`),g}let m;try{m=await this.client.core.history.get(s,t)}catch(g){throw this.client.logger.error(`sendError() -> history.get(${s}, ${t}) failed`),g}if(h){const g=r.getLinkModeURL(c,s,u);await global.Linking.openURL(g,this.client.name)}else{const g=m.request.method,E=o||O[g].res;this.client.core.relayer.publish(s,u,E)}await this.client.core.history.resolve(p)}),l(this,"cleanup",async()=>{const e=[],t=[];this.client.session.getAll().forEach(s=>{let i=!1;r.isExpired(s.expiry)&&(i=!0),this.client.core.crypto.keychain.has(s.topic)||(i=!0),i&&e.push(s.topic)}),this.client.proposal.getAll().forEach(s=>{r.isExpired(s.expiryTimestamp)&&t.push(s.id)}),await Promise.all([...e.map(s=>this.deleteSession({topic:s})),...t.map(s=>this.deleteProposal(s))])}),l(this,"onProviderMessageEvent",async e=>{!this.initialized||this.relayMessageCache.length>0?this.relayMessageCache.push(e):await this.onRelayMessage(e)}),l(this,"onRelayEventRequest",async e=>{this.requestQueue.queue.push(e),await this.processRequestsQueue()}),l(this,"processRequestsQueue",async()=>{if(this.requestQueue.state===M.active){this.client.logger.info("Request queue already active, skipping...");return}for(this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`);this.requestQueue.queue.length>0;){this.requestQueue.state=M.active;const e=this.requestQueue.queue.shift();if(e)try{await this.processRequest(e)}catch(t){this.client.logger.warn(t)}}this.requestQueue.state=M.idle}),l(this,"processRequest",async e=>{const{topic:t,payload:s,attestation:i,transportType:n,encryptedId:o}=e,c=s.method;if(!this.shouldIgnorePairingRequest({topic:t,requestMethod:c}))switch(c){case"wc_sessionPropose":return await this.onSessionProposeRequest({topic:t,payload:s,attestation:i,encryptedId:o});case"wc_sessionSettle":return await this.onSessionSettleRequest(t,s);case"wc_sessionUpdate":return await this.onSessionUpdateRequest(t,s);case"wc_sessionExtend":return await this.onSessionExtendRequest(t,s);case"wc_sessionPing":return await this.onSessionPingRequest(t,s);case"wc_sessionDelete":return await this.onSessionDeleteRequest(t,s);case"wc_sessionRequest":return await this.onSessionRequest({topic:t,payload:s,attestation:i,encryptedId:o,transportType:n});case"wc_sessionEvent":return await this.onSessionEventRequest(t,s);case"wc_sessionAuthenticate":return await this.onSessionAuthenticateRequest({topic:t,payload:s,attestation:i,encryptedId:o,transportType:n});default:return this.client.logger.info(`Unsupported request method ${c}`)}}),l(this,"onRelayEventResponse",async e=>{const{topic:t,payload:s,transportType:i}=e,n=(await this.client.core.history.get(t,s.id)).request.method;switch(n){case"wc_sessionPropose":return this.onSessionProposeResponse(t,s,i);case"wc_sessionSettle":return this.onSessionSettleResponse(t,s);case"wc_sessionUpdate":return this.onSessionUpdateResponse(t,s);case"wc_sessionExtend":return this.onSessionExtendResponse(t,s);case"wc_sessionPing":return this.onSessionPingResponse(t,s);case"wc_sessionRequest":return this.onSessionRequestResponse(t,s);case"wc_sessionAuthenticate":return this.onSessionAuthenticateResponse(t,s);default:return this.client.logger.info(`Unsupported response method ${n}`)}}),l(this,"onRelayEventUnknownPayload",e=>{const{topic:t}=e,{message:s}=r.getInternalError("MISSING_OR_INVALID",`Decoded payload on topic ${t} is not identifiable as a JSON-RPC request or a response.`);throw new Error(s)}),l(this,"shouldIgnorePairingRequest",e=>{const{topic:t,requestMethod:s}=e,i=this.expectedPairingMethodMap.get(t);return!i||i.includes(s)?!1:!!(i.includes("wc_sessionAuthenticate")&&this.client.events.listenerCount("session_authenticate")>0)}),l(this,"onSessionProposeRequest",async e=>{const{topic:t,payload:s,attestation:i,encryptedId:n}=e,{params:o,id:c}=s;try{const p=this.client.core.eventClient.getEvent({topic:t});this.client.events.listenerCount("session_proposal")===0&&(console.warn("No listener for session_proposal event"),p?.setError(d.EVENT_CLIENT_PAIRING_ERRORS.proposal_listener_not_found)),this.isValidConnect(v({},s.params));const u=o.expiryTimestamp||r.calcExpiry(O.wc_sessionPropose.req.ttl),h=v({id:c,pairingTopic:t,expiryTimestamp:u,attestation:i,encryptedId:n},o);await this.setProposal(c,h);const m=await this.getVerifyContext({attestationId:i,hash:r.hashMessage(JSON.stringify(s)),encryptedId:n,metadata:h.proposer.metadata});p?.addTrace(d.EVENT_CLIENT_PAIRING_TRACES.emit_session_proposal),this.client.events.emit("session_proposal",{id:c,params:h,verifyContext:m})}catch(p){await this.sendError({id:c,topic:t,error:p,rpcOpts:O.wc_sessionPropose.autoReject}),this.client.logger.error(p)}}),l(this,"onSessionProposeResponse",async(e,t,s)=>{const{id:i}=t;if(_.isJsonRpcResult(t)){const{result:n}=t;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",result:n});const o=this.client.proposal.get(i);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",proposal:o});const c=o.proposer.publicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",selfPublicKey:c});const p=n.responderPublicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",peerPublicKey:p});const u=await this.client.core.crypto.generateSharedKey(c,p);this.pendingSessions.set(i,{sessionTopic:u,pairingTopic:e,proposalId:i,publicKey:c});const h=await this.client.core.relayer.subscribe(u,{transportType:s});this.client.logger.trace({type:"method",method:"onSessionProposeResponse",subscriptionId:h}),await this.client.core.pairing.activate({topic:e})}else if(_.isJsonRpcError(t)){await this.deleteProposal(i);const n=r.engineEvent("session_connect",i);if(this.events.listenerCount(n)===0)throw new Error(`emitting ${n} without any listeners, 954`);this.events.emit(n,{error:t.error})}}),l(this,"onSessionSettleRequest",async(e,t)=>{const{id:s,params:i}=t;try{this.isValidSessionSettleRequest(i);const{relay:n,controller:o,expiry:c,namespaces:p,sessionProperties:u,scopedProperties:h,sessionConfig:m,proposalRequestsResponses:g}=t.params,E=[...this.pendingSessions.values()].find(N=>N.sessionTopic===e);if(!E)return this.client.logger.error(`Pending session not found for topic ${e}`);const S=this.client.proposal.get(E.proposalId),y=A(v(v(v({topic:e,relay:n,expiry:c,namespaces:p,acknowledged:!0,pairingTopic:E.pairingTopic,requiredNamespaces:S.requiredNamespaces,optionalNamespaces:S.optionalNamespaces,controller:o.publicKey,self:{publicKey:E.publicKey,metadata:this.client.metadata},peer:{publicKey:o.publicKey,metadata:o.metadata}},u&&{sessionProperties:u}),h&&{scopedProperties:h}),m&&{sessionConfig:m}),{transportType:d.TRANSPORT_TYPES.relay,authentication:g?.authentication,walletPayResult:g?.walletPay});await this.client.session.set(y.topic,y),await this.setExpiry(y.topic,y.expiry),await this.client.core.pairing.updateMetadata({topic:E.pairingTopic,metadata:y.peer.metadata}),this.pendingSessions.delete(E.proposalId),this.deleteProposal(E.proposalId,!1),this.cleanupDuplicatePairings(y),await this.sendResult({id:t.id,topic:e,throwOnFailedPublish:!0,result:!0}),this.client.events.emit("session_connect",{session:y}),this.events.emit(r.engineEvent("session_connect",E.proposalId),{session:y})}catch(n){await this.sendError({id:s,topic:e,error:n}),this.client.logger.error(n)}}),l(this,"onSessionSettleResponse",async(e,t)=>{const{id:s}=t;_.isJsonRpcResult(t)?(await this.client.session.update(e,{acknowledged:!0}),this.events.emit(r.engineEvent("session_approve",s),{})):_.isJsonRpcError(t)&&(await this.client.session.delete(e,r.getSdkError("USER_DISCONNECTED")),this.events.emit(r.engineEvent("session_approve",s),{error:t.error}))}),l(this,"onSessionUpdateRequest",async(e,t)=>{const{params:s,id:i}=t;try{const n=`${e}_session_update`,o=r.MemoryStore.get(n);if(o&&this.isRequestOutOfSync(o,i)){this.client.logger.warn(`Discarding out of sync request - ${i}`),this.sendError({id:i,topic:e,error:r.getSdkError("INVALID_UPDATE_REQUEST")});return}this.isValidUpdate(v({topic:e},s));try{r.MemoryStore.set(n,i),await this.client.session.update(e,{namespaces:s.namespaces}),await this.sendResult({id:i,topic:e,result:!0})}catch(c){throw r.MemoryStore.delete(n),c}this.client.events.emit("session_update",{id:i,topic:e,params:s})}catch(n){await this.sendError({id:i,topic:e,error:n}),this.client.logger.error(n)}}),l(this,"isRequestOutOfSync",(e,t)=>t.toString().slice(0,-3)<e.toString().slice(0,-3)),l(this,"onSessionUpdateResponse",(e,t)=>{const{id:s}=t,i=r.engineEvent("session_update",s);if(this.events.listenerCount(i)===0)throw new Error(`emitting ${i} without any listeners`);_.isJsonRpcResult(t)?this.events.emit(r.engineEvent("session_update",s),{}):_.isJsonRpcError(t)&&this.events.emit(r.engineEvent("session_update",s),{error:t.error})}),l(this,"onSessionExtendRequest",async(e,t)=>{const{id:s}=t;try{this.isValidExtend({topic:e}),await this.setExpiry(e,r.calcExpiry(K)),await this.sendResult({id:s,topic:e,result:!0}),this.client.events.emit("session_extend",{id:s,topic:e})}catch(i){await this.sendError({id:s,topic:e,error:i}),this.client.logger.error(i)}}),l(this,"onSessionExtendResponse",(e,t)=>{const{id:s}=t,i=r.engineEvent("session_extend",s);if(this.events.listenerCount(i)===0)throw new Error(`emitting ${i} without any listeners`);_.isJsonRpcResult(t)?this.events.emit(r.engineEvent("session_extend",s),{}):_.isJsonRpcError(t)&&this.events.emit(r.engineEvent("session_extend",s),{error:t.error})}),l(this,"onSessionPingRequest",async(e,t)=>{const{id:s}=t;try{this.isValidPing({topic:e}),await this.sendResult({id:s,topic:e,result:!0,throwOnFailedPublish:!0}),this.client.events.emit("session_ping",{id:s,topic:e})}catch(i){await this.sendError({id:s,topic:e,error:i}),this.client.logger.error(i)}}),l(this,"onSessionPingResponse",(e,t)=>{const{id:s}=t,i=r.engineEvent("session_ping",s);setTimeout(()=>{if(this.events.listenerCount(i)===0)throw new Error(`emitting ${i} without any listeners 2176`);_.isJsonRpcResult(t)?this.events.emit(r.engineEvent("session_ping",s),{}):_.isJsonRpcError(t)&&this.events.emit(r.engineEvent("session_ping",s),{error:t.error})},500)}),l(this,"onSessionDeleteRequest",async(e,t)=>{const{id:s}=t;try{await this.isValidDisconnect({topic:e,reason:t.params}),this.cleanupPendingSentRequestsForTopic({topic:e,error:r.getSdkError("USER_DISCONNECTED")}),await this.deleteSession({topic:e,id:s})}catch(i){this.client.logger.error(i)}}),l(this,"onSessionRequest",async e=>{var t,s,i;const{topic:n,payload:o,attestation:c,encryptedId:p,transportType:u}=e,{id:h,params:m}=o;try{await this.isValidRequest(v({topic:n},m));const g=this.client.session.get(n),E=await this.getVerifyContext({attestationId:c,hash:r.hashMessage(JSON.stringify(_.formatJsonRpcRequest("wc_sessionRequest",m,h))),encryptedId:p,metadata:g.peer.metadata,transportType:u}),S={id:h,topic:n,params:m,verifyContext:E};await this.setPendingSessionRequest(S),u===d.TRANSPORT_TYPES.link_mode&&(t=g.peer.metadata.redirect)!=null&&t.universal&&this.client.core.addLinkModeSupportedApp((s=g.peer.metadata.redirect)==null?void 0:s.universal),(i=this.client.signConfig)!=null&&i.disableRequestQueue?this.emitSessionRequest(S):(this.addSessionRequestToSessionRequestQueue(S),this.processSessionRequestQueue())}catch(g){await this.sendError({id:h,topic:n,error:g}),this.client.logger.error(g)}}),l(this,"onSessionRequestResponse",(e,t)=>{const{id:s}=t,i=r.engineEvent("session_request",s);if(this.events.listenerCount(i)===0)throw new Error(`emitting ${i} without any listeners`);_.isJsonRpcResult(t)?this.events.emit(r.engineEvent("session_request",s),{result:t.result}):_.isJsonRpcError(t)&&this.events.emit(r.engineEvent("session_request",s),{error:t.error})}),l(this,"onSessionEventRequest",async(e,t)=>{const{id:s,params:i}=t;try{const n=`${e}_session_event_${i.event.name}`,o=r.MemoryStore.get(n);if(o&&this.isRequestOutOfSync(o,s)){this.client.logger.info(`Discarding out of sync request - ${s}`);return}this.isValidEmit(v({topic:e},i)),this.client.events.emit("session_event",{id:s,topic:e,params:i}),r.MemoryStore.set(n,s)}catch(n){await this.sendError({id:s,topic:e,error:n}),this.client.logger.error(n)}}),l(this,"onSessionAuthenticateResponse",(e,t)=>{const{id:s}=t;this.client.logger.trace({type:"method",method:"onSessionAuthenticateResponse",topic:e,payload:t}),_.isJsonRpcResult(t)?this.events.emit(r.engineEvent("session_request",s),{result:t.result}):_.isJsonRpcError(t)&&this.events.emit(r.engineEvent("session_request",s),{error:t.error})}),l(this,"onSessionAuthenticateRequest",async e=>{var t;const{topic:s,payload:i,attestation:n,encryptedId:o,transportType:c}=e;try{const{requester:p,authPayload:u,expiryTimestamp:h}=i.params,m=await this.getVerifyContext({attestationId:n,hash:r.hashMessage(JSON.stringify(i)),encryptedId:o,metadata:p.metadata,transportType:c}),g={requester:p,pairingTopic:s,id:i.id,authPayload:u,verifyContext:m,expiryTimestamp:h};await this.setAuthRequest(i.id,{request:g,pairingTopic:s,transportType:c}),c===d.TRANSPORT_TYPES.link_mode&&(t=p.metadata.redirect)!=null&&t.universal&&this.client.core.addLinkModeSupportedApp(p.metadata.redirect.universal),this.client.events.emit("session_authenticate",{topic:s,params:i.params,id:i.id,verifyContext:m})}catch(p){this.client.logger.error(p);const u=i.params.requester.publicKey,h=await this.client.core.crypto.generateKeyPair(),m=this.getAppLinkIfEnabled(i.params.requester.metadata,c),g={type:r.TYPE_1,receiverPublicKey:u,senderPublicKey:h};await this.sendError({id:i.id,topic:s,error:p,encodeOpts:g,rpcOpts:O.wc_sessionAuthenticate.autoReject,appLink:m})}}),l(this,"addSessionRequestToSessionRequestQueue",e=>{this.sessionRequestQueue.queue.push(e)}),l(this,"cleanupAfterResponse",e=>{this.deletePendingSessionRequest(e.response.id,{message:"fulfilled",code:0}),setTimeout(()=>{this.sessionRequestQueue.state=M.idle,this.processSessionRequestQueue()},R.toMiliseconds(this.requestQueueDelay))}),l(this,"cleanupPendingSentRequestsForTopic",({topic:e,error:t})=>{const s=this.client.core.history.pending;s.length>0&&s.filter(i=>i.topic===e&&i.request.method==="wc_sessionRequest").forEach(i=>{this.events.emit(r.engineEvent("session_request",i.request.id),{error:t})})}),l(this,"processSessionRequestQueue",()=>{if(this.sessionRequestQueue.state===M.active){this.client.logger.info("session request queue is already active.");return}const e=this.sessionRequestQueue.queue[0];if(!e){this.client.logger.info("session request queue is empty.");return}try{this.emitSessionRequest(e)}catch(t){this.client.logger.error(t)}}),l(this,"emitSessionRequest",e=>{if(this.emittedSessionRequests.has(e.id)){this.client.logger.warn({id:e.id},`Skipping emitting \`session_request\` event for duplicate request. id: ${e.id}`);return}this.sessionRequestQueue.state=M.active,this.emittedSessionRequests.add(e.id),this.client.events.emit("session_request",e)}),l(this,"onPairingCreated",e=>{if(e.methods&&this.expectedPairingMethodMap.set(e.topic,e.methods),e.active)return;const t=this.client.proposal.getAll().find(s=>s.pairingTopic===e.topic);t&&this.onSessionProposeRequest({topic:e.topic,payload:_.formatJsonRpcRequest("wc_sessionPropose",A(v({},t),{requiredNamespaces:t.requiredNamespaces,optionalNamespaces:t.optionalNamespaces,relays:t.relays,proposer:t.proposer,sessionProperties:t.sessionProperties,scopedProperties:t.scopedProperties}),t.id),attestation:t.attestation,encryptedId:t.encryptedId})}),l(this,"isValidConnect",async e=>{if(!r.isValidParams(e)){const{message:p}=r.getInternalError("MISSING_OR_INVALID",`connect() params: ${JSON.stringify(e)}`);throw new Error(p)}const{pairingTopic:t,requiredNamespaces:s,optionalNamespaces:i,sessionProperties:n,scopedProperties:o,relays:c}=e;if(r.isUndefined(t)||await this.isValidPairingTopic(t),!r.isValidRelays(c,!0)){const{message:p}=r.getInternalError("MISSING_OR_INVALID",`connect() relays: ${c}`);throw new Error(p)}if(s&&!r.isUndefined(s)&&r.isValidObject(s)!==0){const p="requiredNamespaces are deprecated and are automatically assigned to optionalNamespaces";["fatal","error","silent"].includes(this.client.logger.level)?console.warn(p):this.client.logger.warn(p),this.validateNamespaces(s,"requiredNamespaces")}if(i&&!r.isUndefined(i)&&r.isValidObject(i)!==0&&this.validateNamespaces(i,"optionalNamespaces"),n&&!r.isUndefined(n)&&this.validateSessionProps(n,"sessionProperties"),o&&!r.isUndefined(o)){this.validateSessionProps(o,"scopedProperties");const p=Object.keys(s||{}).concat(Object.keys(i||{}));if(!Object.keys(o).every(u=>p.includes(u.split(":")[0])))throw new Error(`Scoped properties must be a subset of required/optional namespaces, received: ${JSON.stringify(o)}, required/optional namespaces: ${JSON.stringify(p)}`)}}),l(this,"validateNamespaces",(e,t)=>{const s=r.isValidRequiredNamespaces(e,"connect()",t);if(s)throw new Error(s.message)}),l(this,"isValidApprove",async e=>{if(!r.isValidParams(e))throw new Error(r.getInternalError("MISSING_OR_INVALID",`approve() params: ${e}`).message);const{id:t,namespaces:s,relayProtocol:i,sessionProperties:n,scopedProperties:o}=e;this.checkRecentlyDeleted(t),await this.isValidProposalId(t);const c=this.client.proposal.get(t),p=r.isValidNamespaces(s,"approve()");if(p)throw new Error(p.message);const u=r.isConformingNamespaces(c.requiredNamespaces,s,"approve()");if(u)throw new Error(u.message);if(!r.isValidString(i,!0)){const{message:h}=r.getInternalError("MISSING_OR_INVALID",`approve() relayProtocol: ${i}`);throw new Error(h)}if(n&&!r.isUndefined(n)&&this.validateSessionProps(n,"sessionProperties"),o&&!r.isUndefined(o)){this.validateSessionProps(o,"scopedProperties");const h=new Set(Object.keys(s));if(!Object.keys(o).every(m=>h.has(m.split(":")[0])))throw new Error(`Scoped properties must be a subset of approved namespaces, received: ${JSON.stringify(o)}, approved namespaces: ${Array.from(h).join(", ")}`)}}),l(this,"isValidReject",async e=>{if(!r.isValidParams(e)){const{message:i}=r.getInternalError("MISSING_OR_INVALID",`reject() params: ${e}`);throw new Error(i)}const{id:t,reason:s}=e;if(this.checkRecentlyDeleted(t),await this.isValidProposalId(t),!r.isValidErrorReason(s)){const{message:i}=r.getInternalError("MISSING_OR_INVALID",`reject() reason: ${JSON.stringify(s)}`);throw new Error(i)}}),l(this,"isValidSessionSettleRequest",e=>{if(!r.isValidParams(e)){const{message:p}=r.getInternalError("MISSING_OR_INVALID",`onSessionSettleRequest() params: ${e}`);throw new Error(p)}const{relay:t,controller:s,namespaces:i,expiry:n}=e;if(!r.isValidRelay(t)){const{message:p}=r.getInternalError("MISSING_OR_INVALID","onSessionSettleRequest() relay protocol should be a string");throw new Error(p)}const o=r.isValidController(s,"onSessionSettleRequest()");if(o)throw new Error(o.message);const c=r.isValidNamespaces(i,"onSessionSettleRequest()");if(c)throw new Error(c.message);if(r.isExpired(n)){const{message:p}=r.getInternalError("EXPIRED","onSessionSettleRequest()");throw new Error(p)}}),l(this,"isValidUpdate",async e=>{if(!r.isValidParams(e)){const{message:c}=r.getInternalError("MISSING_OR_INVALID",`update() params: ${e}`);throw new Error(c)}const{topic:t,namespaces:s}=e;this.checkRecentlyDeleted(t),await this.isValidSessionTopic(t);const i=this.client.session.get(t),n=r.isValidNamespaces(s,"update()");if(n)throw new Error(n.message);const o=r.isConformingNamespaces(i.requiredNamespaces,s,"update()");if(o)throw new Error(o.message)}),l(this,"isValidExtend",async e=>{if(!r.isValidParams(e)){const{message:s}=r.getInternalError("MISSING_OR_INVALID",`extend() params: ${e}`);throw new Error(s)}const{topic:t}=e;this.checkRecentlyDeleted(t),await this.isValidSessionTopic(t)}),l(this,"isValidRequest",async e=>{if(!r.isValidParams(e)){const{message:c}=r.getInternalError("MISSING_OR_INVALID",`request() params: ${e}`);throw new Error(c)}const{topic:t,request:s,chainId:i,expiry:n}=e;this.checkRecentlyDeleted(t),await this.isValidSessionTopic(t);const{namespaces:o}=this.client.session.get(t);if(!r.isValidNamespacesChainId(o,i)){const{message:c}=r.getInternalError("MISSING_OR_INVALID",`request() chainId: ${i}`);throw new Error(c)}if(!r.isValidRequest(s)){const{message:c}=r.getInternalError("MISSING_OR_INVALID",`request() ${JSON.stringify(s)}`);throw new Error(c)}if(!r.isValidNamespacesRequest(o,i,s.method)){const{message:c}=r.getInternalError("MISSING_OR_INVALID",`request() method: ${s.method}`);throw new Error(c)}this.validateRequestExpiry(n)}),l(this,"isValidRespond",async e=>{var t;if(!r.isValidParams(e)){const{message:o}=r.getInternalError("MISSING_OR_INVALID",`respond() params: ${e}`);throw new Error(o)}const{topic:s,response:i}=e;try{await this.isValidSessionTopic(s)}catch(o){throw(t=e?.response)!=null&&t.id&&this.cleanupAfterResponse(e),o}if(!r.isValidResponse(i)){const{message:o}=r.getInternalError("MISSING_OR_INVALID",`respond() response: ${JSON.stringify(i)}`);throw new Error(o)}const n=this.client.pendingRequest.get(i.id);if(n.topic!==s){const{message:o}=r.getInternalError("MISMATCHED_TOPIC",`Request response topic mismatch. reqId: ${i.id}, expected topic: ${n.topic}, received topic: ${s}`);throw new Error(o)}}),l(this,"isValidPing",async e=>{if(!r.isValidParams(e)){const{message:s}=r.getInternalError("MISSING_OR_INVALID",`ping() params: ${e}`);throw new Error(s)}const{topic:t}=e;await this.isValidSessionOrPairingTopic(t)}),l(this,"isValidEmit",async e=>{if(!r.isValidParams(e)){const{message:o}=r.getInternalError("MISSING_OR_INVALID",`emit() params: ${e}`);throw new Error(o)}const{topic:t,event:s,chainId:i}=e;await this.isValidSessionTopic(t);const{namespaces:n}=this.client.session.get(t);if(!r.isValidNamespacesChainId(n,i)){const{message:o}=r.getInternalError("MISSING_OR_INVALID",`emit() chainId: ${i}`);throw new Error(o)}if(!r.isValidEvent(s)){const{message:o}=r.getInternalError("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(s)}`);throw new Error(o)}if(!r.isValidNamespacesEvent(n,i,s.name)){const{message:o}=r.getInternalError("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(s)}`);throw new Error(o)}}),l(this,"isValidDisconnect",async e=>{if(!r.isValidParams(e)){const{message:s}=r.getInternalError("MISSING_OR_INVALID",`disconnect() params: ${e}`);throw new Error(s)}const{topic:t}=e;await this.isValidSessionOrPairingTopic(t)}),l(this,"isValidAuthenticate",e=>{const{chains:t,uri:s,domain:i,nonce:n}=e;if(!Array.isArray(t)||t.length===0)throw new Error("chains is required and must be a non-empty array");if(!r.isValidString(s,!1))throw new Error("uri is required parameter");if(!r.isValidString(i,!1))throw new Error("domain is required parameter");if(!r.isValidString(n,!1))throw new Error("nonce is required parameter");if([...new Set(t.map(c=>r.parseChainId(c).namespace))].length>1)throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");const{namespace:o}=r.parseChainId(t[0]);if(o!=="eip155")throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.")}),l(this,"getVerifyContext",async e=>{const{attestationId:t,hash:s,encryptedId:i,metadata:n,transportType:o}=e,c={verified:{verifyUrl:n.verifyUrl||d.VERIFY_SERVER,validation:"UNKNOWN",origin:n.url||""}};try{if(o===d.TRANSPORT_TYPES.link_mode){const u=this.getAppLinkIfEnabled(n,o);return c.verified.validation=u&&new URL(u).origin===new URL(n.url).origin?"VALID":"INVALID",c}const p=await this.client.core.verify.resolve({attestationId:t,hash:s,encryptedId:i,verifyUrl:n.verifyUrl});p&&(c.verified.origin=p.origin,c.verified.isScam=p.isScam,c.verified.validation=p.origin===new URL(n.url).origin?"VALID":"INVALID")}catch(p){this.client.logger.warn(p)}return this.client.logger.debug(`Verify context: ${JSON.stringify(c)}`),c}),l(this,"validateSessionProps",(e,t)=>{Object.values(e).forEach((s,i)=>{if(s==null){const{message:n}=r.getInternalError("MISSING_OR_INVALID",`${t} must contain an existing value for each key. Received: ${s} for key ${Object.keys(e)[i]}`);throw new Error(n)}})}),l(this,"getPendingAuthRequest",e=>{const t=this.client.auth.requests.get(e);return typeof t=="object"?t:void 0}),l(this,"addToRecentlyDeleted",(e,t)=>{if(this.recentlyDeletedMap.set(e,t),this.recentlyDeletedMap.size>=this.recentlyDeletedLimit){let s=0;const i=this.recentlyDeletedLimit/2;for(const n of this.recentlyDeletedMap.keys()){if(s++>=i)break;this.recentlyDeletedMap.delete(n)}}}),l(this,"checkRecentlyDeleted",e=>{const t=this.recentlyDeletedMap.get(e);if(t){const{message:s}=r.getInternalError("MISSING_OR_INVALID",`Record was recently deleted - ${t}: ${e}`);throw new Error(s)}}),l(this,"isLinkModeEnabled",(e,t)=>{var s,i,n,o,c,p,u,h,m;return!e||t!==d.TRANSPORT_TYPES.link_mode?!1:((i=(s=this.client.metadata)==null?void 0:s.redirect)==null?void 0:i.linkMode)===!0&&((o=(n=this.client.metadata)==null?void 0:n.redirect)==null?void 0:o.universal)!==void 0&&((p=(c=this.client.metadata)==null?void 0:c.redirect)==null?void 0:p.universal)!==""&&((u=e?.redirect)==null?void 0:u.universal)!==void 0&&((h=e?.redirect)==null?void 0:h.universal)!==""&&((m=e?.redirect)==null?void 0:m.linkMode)===!0&&this.client.core.linkModeSupportedApps.includes(e.redirect.universal)&&typeof(global==null?void 0:global.Linking)<"u"}),l(this,"getAppLinkIfEnabled",(e,t)=>{var s;return this.isLinkModeEnabled(e,t)?(s=e?.redirect)==null?void 0:s.universal:void 0}),l(this,"handleLinkModeMessage",({url:e})=>{if(!e||!e.includes("wc_ev")||!e.includes("topic"))return;const t=r.getSearchParamFromURL(e,"topic")||"",s=decodeURIComponent(r.getSearchParamFromURL(e,"wc_ev")||""),i=this.client.session.keys.includes(t);i&&this.client.session.update(t,{transportType:d.TRANSPORT_TYPES.link_mode}),this.client.core.dispatchEnvelope({topic:t,message:s,sessionExists:i})}),l(this,"registerLinkModeListeners",async()=>{var e;if(r.isTestRun()||r.isReactNative()&&(e=this.client.metadata.redirect)!=null&&e.linkMode){const t=global==null?void 0:global.Linking;if(typeof t<"u"){t.addEventListener("url",this.handleLinkModeMessage,this.client.name);const s=await t.getInitialURL();s&&setTimeout(()=>{this.handleLinkModeMessage({url:s})},50)}}}),l(this,"getTVFApproveParams",e=>{try{const t=r.getNamespacesChains(e.namespaces),s=r.getNamespacesMethods(e.namespaces),i=r.getNamespacesEvents(e.namespaces),n=e.sessionProperties,o=e.scopedProperties;return{approvedChains:t,approvedMethods:s,approvedEvents:i,sessionProperties:n,scopedProperties:o}}catch(t){return this.client.logger.warn(t,"Error getting TVF approve params"),{}}}),l(this,"getTVFParams",(e,t,s)=>{var i,n,o;if(!((i=t.request)!=null&&i.method))return{};const c={correlationId:e,rpcMethods:[t.request.method],chainId:t.chainId};try{const p=this.extractTxHashesFromResult(t.request,s);c.txHashes=p,c.contractAddresses=this.isValidContractData(t.request.params)?[(o=(n=t.request.params)==null?void 0:n[0])==null?void 0:o.to]:[]}catch(p){this.client.logger.warn(p,"Error getting TVF params")}return c}),l(this,"isValidContractData",e=>{var t;if(!e)return!1;try{const s=e?.data||((t=e?.[0])==null?void 0:t.data);if(!s.startsWith("0x"))return!1;const i=s.slice(2);return/^[0-9a-fA-F]*$/.test(i)?i.length%2===0:!1}catch{}return!1}),l(this,"extractTxHashesFromResult",(e,t)=>{var s;try{if(!t)return[];const i=e.method,n=Ne[i];if(i==="sui_signTransaction")return[r.getSuiDigest(t.transactionBytes)];if(i==="near_signTransaction")return[r.getNearTransactionIdFromSignedTransaction(t)];if(i==="near_signTransactions")return t.map(c=>r.getNearTransactionIdFromSignedTransaction(c));if(i==="xrpl_signTransactionFor"||i==="xrpl_signTransaction")return[(s=t.tx_json)==null?void 0:s.hash];if(i==="polkadot_signTransaction")return[r.buildSignedExtrinsicHash({transaction:e.params.transactionPayload,signature:t.signature})];if(i==="algo_signTxn")return r.isValidArray(t)?t.map(c=>r.getAlgorandTransactionId(c)):[r.getAlgorandTransactionId(t)];if(i==="cosmos_signDirect")return[r.getSignDirectHash(t)];if(i==="wallet_sendCalls")return r.getWalletSendCallsHashes(t);if(typeof t=="string")return[t];const o=t[n.key];if(r.isValidArray(o))return i==="solana_signAllTransactions"?o.map(c=>r.extractSolanaTransactionId(c)):o;if(typeof o=="string")return[o]}catch(i){this.client.logger.warn(i,"Error extracting tx hashes from result")}return[]})}async processPendingMessageEvents(){try{const a=this.client.session.keys,e=this.client.core.relayer.messages.getWithoutAck(a);for(const[t,s]of Object.entries(e))for(const i of s)try{await this.onProviderMessageEvent({topic:t,message:i,publishedAt:Date.now()})}catch{this.client.logger.warn(`Error processing pending message event for topic: ${t}, message: ${i}`)}}catch(a){this.client.logger.warn(a,"processPendingMessageEvents failed")}}isInitialized(){if(!this.initialized){const{message:a}=r.getInternalError("NOT_INITIALIZED",this.name);throw new Error(a)}}async confirmOnlineStateOrThrow(){await this.client.core.relayer.confirmOnlineStateOrThrow()}registerRelayerEvents(){this.client.core.relayer.on(d.RELAYER_EVENTS.message,a=>{this.onProviderMessageEvent(a)})}async onRelayMessage(a){const{topic:e,message:t,attestation:s,transportType:i}=a,{publicKey:n}=this.client.auth.authKeys.keys.includes(B)?this.client.auth.authKeys.get(B):{responseTopic:void 0,publicKey:void 0};try{const o=await this.client.core.crypto.decode(e,t,{receiverPublicKey:n,encoding:i===d.TRANSPORT_TYPES.link_mode?r.BASE64URL:r.BASE64});_.isJsonRpcRequest(o)?(this.client.core.history.set(e,o),await this.onRelayEventRequest({topic:e,payload:o,attestation:s,transportType:i,encryptedId:r.hashMessage(t)})):_.isJsonRpcResponse(o)?(await this.client.core.history.resolve(o),await this.onRelayEventResponse({topic:e,payload:o,transportType:i}),this.client.core.history.delete(e,o.id)):(this.client.logger.error(`onRelayMessage() -> unknown payload: ${JSON.stringify(o)}`),await this.onRelayEventUnknownPayload({topic:e,payload:o,transportType:i})),await this.client.core.relayer.messages.ack(e,t)}catch(o){this.client.logger.error(`onRelayMessage() -> failed to process an inbound message: ${t}`),this.client.logger.error(o)}}registerExpirerEvents(){this.client.core.expirer.on(d.EXPIRER_EVENTS.expired,async a=>{const{topic:e,id:t}=r.parseExpirerTarget(a.target);if(t&&this.client.pendingRequest.keys.includes(t))return await this.deletePendingSessionRequest(t,r.getInternalError("EXPIRED"),!0);if(t&&this.client.auth.requests.keys.includes(t))return await this.deletePendingAuthRequest(t,r.getInternalError("EXPIRED"),!0);e?this.client.session.keys.includes(e)&&(await this.deleteSession({topic:e,expirerHasDeleted:!0}),this.client.events.emit("session_expire",{topic:e})):t&&(await this.deleteProposal(t,!0),this.client.events.emit("proposal_expire",{id:t}))})}registerPairingEvents(){this.client.core.pairing.events.on(d.PAIRING_EVENTS.create,a=>this.onPairingCreated(a)),this.client.core.pairing.events.on(d.PAIRING_EVENTS.delete,a=>{this.addToRecentlyDeleted(a.topic,"pairing")})}isValidPairingTopic(a){if(!r.isValidString(a,!1)){const{message:e}=r.getInternalError("MISSING_OR_INVALID",`pairing topic should be a string: ${a}`);throw new Error(e)}if(!this.client.core.pairing.pairings.keys.includes(a)){const{message:e}=r.getInternalError("NO_MATCHING_KEY",`pairing topic doesn't exist: ${a}`);throw new Error(e)}if(r.isExpired(this.client.core.pairing.pairings.get(a).expiry)){const{message:e}=r.getInternalError("EXPIRED",`pairing topic: ${a}`);throw new Error(e)}}async isValidSessionTopic(a){if(!r.isValidString(a,!1)){const{message:e}=r.getInternalError("MISSING_OR_INVALID",`session topic should be a string: ${a}`);throw new Error(e)}if(this.checkRecentlyDeleted(a),!this.client.session.keys.includes(a)){const{message:e}=r.getInternalError("NO_MATCHING_KEY",`session topic doesn't exist: ${a}`);throw new Error(e)}if(r.isExpired(this.client.session.get(a).expiry)){await this.deleteSession({topic:a});const{message:e}=r.getInternalError("EXPIRED",`session topic: ${a}`);throw new Error(e)}if(!this.client.core.crypto.keychain.has(a)){const{message:e}=r.getInternalError("MISSING_OR_INVALID",`session topic does not exist in keychain: ${a}`);throw await this.deleteSession({topic:a}),new Error(e)}}async isValidSessionOrPairingTopic(a){if(this.checkRecentlyDeleted(a),this.client.session.keys.includes(a))await this.isValidSessionTopic(a);else if(this.client.core.pairing.pairings.keys.includes(a))this.isValidPairingTopic(a);else if(r.isValidString(a,!1)){const{message:e}=r.getInternalError("NO_MATCHING_KEY",`session or pairing topic doesn't exist: ${a}`);throw new Error(e)}else{const{message:e}=r.getInternalError("MISSING_OR_INVALID",`session or pairing topic should be a string: ${a}`);throw new Error(e)}}async isValidProposalId(a){if(!r.isValidId(a)){const{message:e}=r.getInternalError("MISSING_OR_INVALID",`proposal id should be a number: ${a}`);throw new Error(e)}if(!this.client.proposal.keys.includes(a)){const{message:e}=r.getInternalError("NO_MATCHING_KEY",`proposal id doesn't exist: ${a}`);throw new Error(e)}if(r.isExpired(this.client.proposal.get(a).expiryTimestamp)){await this.deleteProposal(a);const{message:e}=r.getInternalError("EXPIRED",`proposal id: ${a}`);throw new Error(e)}}validateRequestExpiry(a){if(a&&!r.isValidRequestExpiry(a,se)){const{message:e}=r.getInternalError("MISSING_OR_INVALID",`request() expiry: ${a}. Expiry must be a number (in seconds) between ${se.min} and ${se.max}`);throw new Error(e)}}}class Ze extends d.Store{constructor(a,e){super(a,e,Re,ee),this.core=a,this.logger=e}}class xe extends d.Store{constructor(a,e){super(a,e,Ie,ee),this.core=a,this.logger=e}}class et extends d.Store{constructor(a,e){super(a,e,fe,ee,t=>t.id),this.core=a,this.logger=e}}class tt extends d.Store{constructor(a,e){super(a,e,Ae,z,()=>B),this.core=a,this.logger=e}}class st extends d.Store{constructor(a,e){super(a,e,Ce,z),this.core=a,this.logger=e}}class it extends d.Store{constructor(a,e){super(a,e,Ve,z,t=>t.id),this.core=a,this.logger=e}}var rt=Object.defineProperty,nt=(w,a,e)=>a in w?rt(w,a,{enumerable:!0,configurable:!0,writable:!0,value:e}):w[a]=e,ge=(w,a,e)=>nt(w,typeof a!="symbol"?a+"":a,e);class ot{constructor(a,e){this.core=a,this.logger=e,ge(this,"authKeys"),ge(this,"pairingTopics"),ge(this,"requests"),this.authKeys=new tt(this.core,this.logger),this.pairingTopics=new st(this.core,this.logger),this.requests=new it(this.core,this.logger)}async init(){await this.authKeys.init(),await this.pairingTopics.init(),await this.requests.init()}}var at=Object.defineProperty,ct=(w,a,e)=>a in w?at(w,a,{enumerable:!0,configurable:!0,writable:!0,value:e}):w[a]=e,T=(w,a,e)=>ct(w,typeof a!="symbol"?a+"":a,e);class ie extends Te.ISignClient{constructor(a){super(a),T(this,"protocol",ce),T(this,"version",le),T(this,"name",te.name),T(this,"metadata"),T(this,"core"),T(this,"logger"),T(this,"events",new we.EventEmitter),T(this,"engine"),T(this,"session"),T(this,"proposal"),T(this,"pendingRequest"),T(this,"auth"),T(this,"signConfig"),T(this,"on",(t,s)=>this.events.on(t,s)),T(this,"once",(t,s)=>this.events.once(t,s)),T(this,"off",(t,s)=>this.events.off(t,s)),T(this,"removeListener",(t,s)=>this.events.removeListener(t,s)),T(this,"removeAllListeners",t=>this.events.removeAllListeners(t)),T(this,"connect",async t=>{try{return await this.engine.connect(t)}catch(s){throw this.logger.error(s.message),s}}),T(this,"pair",async t=>{try{return await this.engine.pair(t)}catch(s){throw this.logger.error(s.message),s}}),T(this,"approve",async t=>{try{return await this.engine.approve(t)}catch(s){throw this.logger.error(s.message),s}}),T(this,"reject",async t=>{try{return await this.engine.reject(t)}catch(s){throw this.logger.error(s.message),s}}),T(this,"update",async t=>{try{return await this.engine.update(t)}catch(s){throw this.logger.error(s.message),s}}),T(this,"extend",async t=>{try{return await this.engine.extend(t)}catch(s){throw this.logger.error(s.message),s}}),T(this,"request",async t=>{try{return await this.engine.request(t)}catch(s){throw this.logger.error(s.message),s}}),T(this,"respond",async t=>{try{return await this.engine.respond(t)}catch(s){throw this.logger.error(s.message),s}}),T(this,"ping",async t=>{try{return await this.engine.ping(t)}catch(s){throw this.logger.error(s.message),s}}),T(this,"emit",async t=>{try{return await this.engine.emit(t)}catch(s){throw this.logger.error(s.message),s}}),T(this,"disconnect",async t=>{try{return await this.engine.disconnect(t)}catch(s){throw this.logger.error(s.message),s}}),T(this,"find",t=>{try{return this.engine.find(t)}catch(s){throw this.logger.error(s.message),s}}),T(this,"getPendingSessionRequests",()=>{try{return this.engine.getPendingSessionRequests()}catch(t){throw this.logger.error(t.message),t}}),T(this,"authenticate",async(t,s)=>{try{return await this.engine.authenticate(t,s)}catch(i){throw this.logger.error(i.message),i}}),T(this,"formatAuthMessage",t=>{try{return this.engine.formatAuthMessage(t)}catch(s){throw this.logger.error(s.message),s}}),T(this,"approveSessionAuthenticate",async t=>{try{return await this.engine.approveSessionAuthenticate(t)}catch(s){throw this.logger.error(s.message),s}}),T(this,"rejectSessionAuthenticate",async t=>{try{return await this.engine.rejectSessionAuthenticate(t)}catch(s){throw this.logger.error(s.message),s}}),this.name=a?.name||te.name,this.metadata=r.populateAppMetadata(a?.metadata),this.signConfig=a?.signConfig;const e=r.createLogger({logger:a?.logger||te.logger,name:this.name});this.logger=e,this.core=a?.core||new d.Core(a),this.session=new xe(this.core,this.logger),this.proposal=new Ze(this.core,this.logger),this.pendingRequest=new et(this.core,this.logger),this.engine=new We(this),this.auth=new ot(this.core,this.logger)}static async init(a){const e=new ie(a);return await e.initialize(),e}get context(){return De.getLoggerContext(this.logger)}get pairing(){return this.core.pairing.pairings}async initialize(){this.logger.trace("Initialized");try{await this.core.start(),await this.session.init(),await this.proposal.init(),await this.pendingRequest.init(),await this.auth.init(),await this.engine.init(),this.logger.info("SignClient Initialization Success")}catch(a){throw this.logger.info("SignClient Initialization Failure"),this.logger.error(a.message),a}}}const lt=xe,pt=ie;exports.AUTH_CONTEXT=Oe,exports.AUTH_KEYS_CONTEXT=Ae,exports.AUTH_PAIRING_TOPIC_CONTEXT=Ce,exports.AUTH_PROTOCOL=qe,exports.AUTH_PUBLIC_KEY_NAME=B,exports.AUTH_REQUEST_CONTEXT=Ve,exports.AUTH_STORAGE_PREFIX=z,exports.AUTH_VERSION=je,exports.ENGINE_CONTEXT=ve,exports.ENGINE_QUEUE_STATES=M,exports.ENGINE_RPC_OPTS=O,exports.HISTORY_CONTEXT=Ge,exports.HISTORY_EVENTS=Ke,exports.HISTORY_STORAGE_VERSION=Ye,exports.METHODS_TO_VERIFY=Pe,exports.PROPOSAL_CONTEXT=Re,exports.PROPOSAL_EXPIRY=He,exports.PROPOSAL_EXPIRY_MESSAGE=de,exports.REQUEST_CONTEXT=fe,exports.SESSION_CONTEXT=Ie,exports.SESSION_EXPIRY=K,exports.SESSION_REQUEST_EXPIRY_BOUNDARIES=se,exports.SIGN_CLIENT_CONTEXT=pe,exports.SIGN_CLIENT_DEFAULT=te,exports.SIGN_CLIENT_EVENTS=$e,exports.SIGN_CLIENT_PROTOCOL=ce,exports.SIGN_CLIENT_STORAGE_OPTIONS=Fe,exports.SIGN_CLIENT_STORAGE_PREFIX=ee,exports.SIGN_CLIENT_VERSION=le,exports.SessionStore=lt,exports.SignClient=pt,exports.TVF_METHODS=Ne,exports.WALLETCONNECT_DEEPLINK_CHOICE=he,exports.default=ie;
//# sourceMappingURL=index.cjs.map
